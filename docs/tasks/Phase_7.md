# フェーズ7: 要約・レンダリング — タスク一覧

## タスク1: 要約プロンプトと LLM 呼び出しの実装
- 取得済み本文 + スニペットを入力に、`gpt-4o-mini` (温度 0.3, timeout 15s, max_retries=1) で Markdown 要約と根拠番号を生成する関数を実装する。
- プロンプトにはサービス別セクション例・根拠リンク付けルール（本文順に 1..N で採番）を含める。

### 受入基準 (Gherkin)
```
シナリオ: 3サービス混在の本文を Markdown 要約する
  前提: Slack/GitHub/Drive の本文モックがあり、各サービス最大3件の FetchResult がある
  もし: 要約関数を gpt-4o-mini (温度0.3, timeout15s, retry1回) で呼び出す
  ならば: サービス別の小見出しと箇条書き要約が Markdown で返り、本文がある件数分だけ根拠リンク番号が 1..N で付与される
```
```
シナリオ: スキーマ不整合時にリトライ後エラーを返す
  前提: モデル応答が Schema を満たさない JSON を返す
  もし: 要約関数を呼び出す
  ならば: 1 回リトライした上で ValueError を送出し、リトライ回数がログに警告として記録される
```

## タスク2: 根拠リンクの番号付けと URI 整形
- サービス横断で重複なく 1 から連番を採番し、Markdown の `[n] タイトル (サービス)` / `URI` 形式に整形するヘルパーを実装する。
- FetchResult に URI が無い場合は警告文を生成しリンクリストから除外する。

### 受入基準 (Gherkin)
```
シナリオ: 根拠リンクが連番かつサービス横断で一意
  前提: 5 件の FetchResult が Slack/Drive/GitHub から渡される
  もし: 根拠整形ヘルパーを呼び出す
  ならば: `[1]` から `[5]` まで欠番なく採番され、同一 URI の重複は 1 度だけ出力される
```
```
シナリオ: URI 欠落時に警告し除外する
  前提: 1 件の FetchResult に uri フィールドが無い
  もし: 根拠整形ヘルパーを呼び出す
  ならば: 当該項目がリンク出力から省かれ、"URI missing" を含む警告が warnings に追加される
```

## タスク3: Rich による要約結果レンダリング
- REPL/ワンショット共通で、Rich の Markdown レンダラを用い「サービス別セクション + 番号付き根拠リンク」を描画する表示関数を追加する。
- 代替クエリがある場合は末尾に "次の検索候補" セクションを表示する。

### 受入基準 (Gherkin)
```
シナリオ: 要約と根拠リンクが CLI に整形表示される
  前提: 要約テキストと根拠リンクリストが生成済みである
  もし: 表示関数を呼び出す
  ならば: コンソールにサービス別の見出し、箇条書き要約、番号付き根拠リンク、代替クエリ (存在時のみ) が順序通りに描画される
```
```
シナリオ: 非TTYでも崩れず出力される
  前提: stdout が TTY ではない環境である
  もし: 表示関数を呼び出す
  ならば: ANSI コードに依存せず Markdown テキストがそのまま出力され、例外やレイアウト崩れが発生しない
```

## タスク4: 0 件時の即時終了と代替クエリ提示
- 検索結果が空の場合は要約 API を呼ばず、代替クエリ候補のみを表示して終了するフローを実装する。
- 代替クエリが無い場合は固定メッセージを出す。

### 受入基準 (Gherkin)
```
シナリオ: 検索結果 0 件で要約呼び出しをスキップする
  前提: 検索結果リストが空で代替クエリが2件ある
  もし: フローを実行する
  ならば: 要約 API は呼ばれず、代替クエリだけが表示され、処理全体が 0.5 秒以内で終了する
```
```
シナリオ: 代替クエリが無い場合に固定メッセージを表示
  前提: 検索結果リストが空で代替クエリが空リストである
  もし: フローを実行する
  ならば: "代替クエリを生成できませんでした" を含むメッセージが表示される
```

## タスク5: 要約フェイルソフトとログ出力
- LLM 呼び出しがタイムアウト/例外の場合は、要約なしで取得本文のタイトル＋URI を列挙するフォールバックを返し、警告ログと warnings を残す。
- `--debug` 時のみ LLM 入出力の JSONL を `logs/` に追記する（平常時は本文を永続化しない）。

### 受入基準 (Gherkin)
```
シナリオ: 要約失敗時にフォールバックを表示して続行する
  前提: 要約 API が TimeoutError を投げる
  もし: フローを実行する
  ならば: 要約文の代わりに取得本文のタイトルと URI の一覧が表示され、処理は例外を投げず warnings にタイムアウト警告が含まれる
```
```
シナリオ: --debug 時のみ要約入出力がファイルに記録される
  前提: --debug フラグが有効で要約 API が正常応答を返す
  もし: フローを実行する
  ならば: `logs/` 配下に JSON Lines 形式で LLM 入出力が追記され、--debug 無効時には同ファイルが生成されない
```

## タスク6: 要約付き E2E モックテスト
- Phase6 のモックパイプラインに要約ステップを連結し、モック要約レスポンダで E2E を自動テストする Pytest を追加する。
- 並列検索・取得・要約を通して 2 秒未満で完了することを検証する。

### 受入基準 (Gherkin)
```
シナリオ: 要約まで含めて 3 サービス分が返る
  前提: 3 サービスの検索・取得・要約モックが成功する
  もし: パイプラインを実行する
  ならば: 3 サービス分の要約と根拠リンクが返り、各サービス 3 件以内で番号付けされる
```
```
シナリオ: 要約ステップ失敗時も検索・取得結果が返る
  前提: 要約モックが例外を投げ、検索・取得モックは成功する
  もし: パイプラインを実行する
  ならば: 要約なしのフォールバックが表示され、検索・取得結果は失われず警告が記録される
```
```
シナリオ: 全ステップが並列実行され 2 秒未満で完了する
  前提: 検索・取得・要約モックがそれぞれ 0.5 秒の遅延を持つ
  もし: パイプラインを実行する
  ならば: 総処理時間が 2 秒未満となり、並列化が有効であることが確認できる
```

---

## タスク7: MCP 検索接続の実装 ✅ 完了

### 実装サマリー

TDD で以下を実装:

1. **MCP プロトコル対応モックサーバー**
   - `tests/mocks/base_mcp_server.py`: JSON-RPC 2.0 対応の基底クラス
   - `tests/mocks/{slack,github,gdrive}_server.py`: 各サービスのモックサーバー

2. **MCP ランナー統合**
   - `app/mcp_runners.py`: `run_oneshot_with_mcp()` 関数を追加
   - サービス名正規化 (`drive` → `gdrive`) に対応

3. **メインエントリーポイント統合**
   - `app/__main__.py`: LLM クライアントがある場合は MCP パイプラインを使用

4. **テスト**
   - `tests/test_oneshot_mcp_integration.py`: 7 つの統合テスト
   - 全 87 テストがパス

### 背景

現在、`python -m app --query "LLM"` を実行すると：
- LLM クライアントが初期化され、検索パラメータが生成される
- しかし、実際の MCP サーバーへの検索は実行されていない
- `search_runner` がデフォルトの fallback lambda を使用しているため

### 目標

oneshot モードで MCP サーバーを起動し、実際に検索・取得・要約を行えるようにする。

### 実装すべき内容

1. **oneshot モードでの MCP サーバー起動**
   - `app/__main__.py` の `main()` 関数で、oneshot モード時にも MCP サーバーを起動する
   - `launch_services_async()` を呼び出してサーバープロセスを取得する
   - 参考: REPL モードでは `_run_startup_with_status_board()` で起動している

2. **MCP クライアント接続の実装**
   - `app/mcp_runners.py` の `StdioMcpClient` を完成させる
   - 起動した MCP サーバーの stdin/stdout と通信できるようにする
   - MCP プロトコル (JSON-RPC 2.0) に準拠したリクエスト/レスポンス処理

3. **search_runner / fetch_runner の生成**
   - `create_mcp_runners_from_processes()` を使って実際のランナーを生成
   - `prepare_mode_aware_runners()` と組み合わせてモード切り替えに対応

4. **パイプライン統合**
   - `run_search_fetch_and_summarize_pipeline()` を使って全パイプラインを実行
   - 結果を `render_summary_with_links()` で表示

### 参考ファイル

- `app/process.py` - MCP サーバーの起動・監視ロジック
- `app/search_pipeline.py` - 検索・取得パイプライン
- `app/summary_pipeline.py` - 要約パイプライン（`run_search_fetch_and_summarize_pipeline`）
- `app/mcp_runners.py` - MCP クライアントランナー（現在はプレースホルダー）
- `tests/test_search_pipeline_integration.py` - パイプライン統合テストの参考実装

### 受入基準 (Gherkin)

```
シナリオ: oneshot モードで MCP 経由のデータ取得が動作する
  前提: .env に OPENAI_API_KEY, SLACK_USER_TOKEN, GITHUB_TOKEN, DRIVE_TOKEN_PATH が設定済み
  かつ: servers.yaml で各サービスが mode: real に設定されている
  もし: poetry run python -m app --query "設計ドキュメント" を実行する
  ならば: MCP サーバーが起動し、実際の検索が実行される
  かつ: 検索結果が取得され、LLM による要約が生成される
  かつ: 根拠リンク付きの結果が表示される
```
```
シナリオ: --mock モードではモックサーバーが使用される
  前提: --mock オプションが指定されている
  もし: poetry run python -m app --mock --query "テスト" を実行する
  ならば: モックサーバーが起動し、モックデータで検索が実行される
```
```
シナリオ: MCP サーバー起動失敗時にエラーメッセージを表示
  前提: 必要な認証情報が不足している
  もし: poetry run python -m app --query "テスト" を実行する
  ならば: どのサービスが起動失敗したかを示す警告が表示される
  かつ: 起動成功したサービスでは検索が実行される
```

### 注意事項

- MCP サーバーとの通信は stdio (標準入出力) 経由
- 各サーバーは異なる形式のレスポンスを返す可能性があるため、`search_mapping.py` の正規化ロジックを活用
- サーバー起動のタイムアウト処理を適切に設定
- 既存のテスト (`test_search_pipeline_integration.py` など) が引き続きパスすることを確認
